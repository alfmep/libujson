//
// Copyright (C) 2017,2019,2021,2022 Dan Arrhenius <dan@ultramarin.se>
//
// This file is part of ujson.
//
// ujson is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published
// by the Free Software Foundation, either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.
//
%skeleton "lalr1.cc"
%require "3.0.4"
%defines
%define api.namespace {ujson}
%define api.prefix {uj}
%define parser_class_name {Analyzer}

%define api.token.constructor
%define api.value.type variant
%define parse.assert

%code requires {
    #include <string>
    namespace ujson {
        class Parser;
    }
    typedef void* yyscan_t;
}

// The parsing context.
%param { ujson::Parser& parser }
%param { yyscan_t yyscanner }

%locations
%initial-action {
    // Initialize the initial location.
    @$.begin.filename = @$.end.filename = &parser.file;
};

%define parse.trace
%define parse.error verbose

%code {
    #include <ujson/Parser.hpp>
}

%define api.token.prefix {TOK_}
%token
END 0 "end of file"
LBRACK "["
RBRACK "]"
LCBRACK "{"
RCBRACK "}"
SEPARATOR ","
COLON ":"
;
%token <std::string> IDENTIFIER "identifier"
%token <std::string> STRING     "string"
%token <double>      NUMBER     "number"
%token <bool>        TRUE       "true"
%token <bool>        FALSE      "false"
%token <int>         NULL       "null"

%%
%start instance;

instance:       str_value                {parser.on_parse_str_value(true);}
        |       NUMBER                   {parser.on_parse_number($1, true);}
        |       object                   {parser.on_parse_root();}
        |       array                    {parser.on_parse_root();}
        |       TRUE                     {parser.on_parse_bool(true, true);}
        |       FALSE                    {parser.on_parse_bool(false, true);}
        |       NULL                     {parser.on_parse_null(true);}
                ;

object:         LCBRACK RCBRACK          {parser.on_parse_object();}
        |       LCBRACK members RCBRACK  {parser.on_parse_object();}
                ;

members:        pair SEPARATOR members   {parser.on_parse_member();}
        |       pair SEPARATOR           {parser.on_parse_member(true);}
        |       pair                     {parser.on_parse_member();}
                ;

pair:           STRING COLON value       {parser.on_parse_pair($1);}
        |       IDENTIFIER COLON value   {parser.on_parse_pair($1, true);}
                ;

array:          LBRACK RBRACK            {parser.on_parse_array();}
        |       LBRACK elements RBRACK   {parser.on_parse_array();}
                ;

elements:       value SEPARATOR elements {parser.on_parse_element();}
        |       value SEPARATOR          {parser.on_parse_element(true);}
        |       value                    {parser.on_parse_element();}
                ;

value:          str_value                {parser.on_parse_str_value();}
        |       NUMBER                   {parser.on_parse_number($1);}
        |       object
        |       array
        |       TRUE                     {parser.on_parse_bool(true);}
        |       FALSE                    {parser.on_parse_bool(false);}
        |       NULL                     {parser.on_parse_null();}
                ;

str_value:	STRING                   {parser.on_parse_string($1);}
	|	STRING str_value         {parser.on_parse_string($1, true);}
		;
%%


//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
void ujson::Analyzer::error (const location_type& l,
                             const std::string& m)
{
    parser.error (l, m);
}
